import { LRParser } from '@lezer/lr';
import { LRLanguage, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';
import { styleTags, tags } from '@lezer/highlight';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_Comment = {__proto__:null,"# int pool":37, "# string pool":37, "# function_pool":37, "# native pool":37};
const parser = LRParser.deserialize({
  version: 14,
  states: "#rQVQPOOOOQO'#Ch'#ChOeQPO'#C_OOQO'#Cb'#CbOmQQO'#CeOrQPO'#CdOOQO'#C^'#C^OOQO'#Cg'#CgQVQPOOOOQO-E6f-E6fOOQO'#Ci'#CiOzQPO,58yO!`QPO,59POOQO'#Cj'#CjO!eQPO,59OOOQO,59O,59OOOQO-E6e-E6eOOQO-E6g-E6gOOQO1G.k1G.kOOQO-E6h-E6hOOQO1G.j1G.j",
  stateData: "!m~OaOS~OSPOVUObROcSO~OSPOTYO~OY[O~OSPOV_O~OTYOSRaVRa_RabRacRa~OdbO~OSPOVdO~O",
  goto: "!a_PP`dPPlPlpPtz!T!ZTVOWSUOWT]T^TUOWTTOWQWOR`WWQOTW^RXQQZQRaZQ^TRc^",
  nodeNames: "âš  Program Expression Line Byte Comment BlockHeader BlockEnder Function FuncHeader Identifier",
  maxTerm: 20,
  skippedNodes: [0],
  repeatNodeCount: 4,
  tokenData: "$a~R[XYwYZ|pqwst!Z}!O!t!Q![#Y!`!a$[!c!i#Y!i!}!t#R#S!t#T#Z#Y#Z#o!t~|Oa~~!RPa~YZ!U~!ZOV~~!^Qpq!d!^!_!o~!iQT~OY!dZ~!d~!tOc~Q!yTYQ}!O!t!Q![!t!c!}!t#R#S!t#T#o!tR#_VYQ}!O!t!Q![#t!c!i#t!i!}!t#R#S!t#T#Z#t#Z#o!tR#{TSPYQ}!O!t!Q![!t!c!}!t#R#S!t#T#o!t~$aOd~",
  tokenizers: [0, 1],
  topRules: {"Program":[0,1]},
  specialized: [{term: 5, get: value => spec_Comment[value] || -1}],
  tokenPrec: 0
});

const BC0Language = LRLanguage.define({
    parser: parser.configure({
        props: [
            foldNodeProp.add({
                Function: foldInside,
            }),
            styleTags({
                Byte: tags.integer,
                Comment: tags.comment,
                FuncHeader: tags.className,
                BlockHeader: tags.className
            })
        ]
    }),
    languageData: {
        commentTokens: { line: "# " }
    },
});
function BC0() {
    return new LanguageSupport(BC0Language);
}

export { BC0, BC0Language };
